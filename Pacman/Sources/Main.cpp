//
// Main.cpp
//

#include "pch.h"
#include "Game.h"


using namespace DirectX;


namespace
{
  std::unique_ptr<Game> g_game;
};

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

//ハイブリッドグラフィックスシステムにディスクリートパートを優先するよう指示
extern "C"
{
  __declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001;
  __declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
}

//エントリーポイント
int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow)
{
  UNREFERENCED_PARAMETER(hPrevInstance);
  UNREFERENCED_PARAMETER(lpCmdLine);
  //CPUサポートの確認
  if (!XMVerifyCPUSupport())
    return 1;
  //COMの初期化
  HRESULT hr = CoInitializeEx(nullptr, COINITBASE_MULTITHREADED);
  if (FAILED(hr))
    return 1;
  //ゲームオブジェクトの作成
  g_game = std::make_unique<Game>();

  //クラスの登録とウィンドウの作成
  {
	//クラスの登録
    WNDCLASSEX wcex = {};
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon(hInstance, L"IDI_ICON");
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszClassName = L"PacmanWindowClass";
    wcex.hIconSm = LoadIcon(wcex.hInstance, L"IDI_ICON");
    if (!RegisterClassEx(&wcex))
      return 1;

	//ウィンドウの作成
    uint16_t w, h;
    g_game->GetDefaultSize(w, h);

    RECT rc = { 0, 0, static_cast<LONG>(w), static_cast<LONG>(h) };

    AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, FALSE);

    HWND hwnd = CreateWindowEx(0, L"PacmanWindowClass", L"Pacman", WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,
      nullptr);

    if (!hwnd)
      return 1;

    ShowWindow(hwnd, nCmdShow);
	//デフォルトをフルスクリーンにするにはnCmdShowをSW_SHOWMAXIMIZED に変更する

    SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(g_game.get()));

    GetClientRect(hwnd, &rc);

    g_game->Initialize(hwnd, static_cast<uint16_t>(rc.right - rc.left), static_cast<uint16_t>(rc.bottom - rc.top));
  }

  //メインメッセージループ
  MSG msg = {};
  while (WM_QUIT != msg.message)
  {
    if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
    {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    }
    else
    {
      g_game->Tick();
    }
  }

  g_game.reset();

  CoUninitialize();

  return static_cast<int>(msg.wParam);
}

//Windowsプロシージャ
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  PAINTSTRUCT ps;
  HDC hdc;

  static bool s_in_sizemove = false;
  static bool s_in_suspend = false;
  static bool s_minimized = false;
  static bool s_fullscreen = false;

  auto game = reinterpret_cast<Game*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

  switch (message)
  {
  case WM_PAINT:
    if (s_in_sizemove && game)
    {
      game->Tick();
    }
    else
    {
      hdc = BeginPaint(hWnd, &ps);
      EndPaint(hWnd, &ps);
    }
    break;

  case WM_SIZE:
    if (wParam == SIZE_MINIMIZED)
    {
      if (!s_minimized)
      {
        s_minimized = true;
        if (!s_in_suspend && game)
          game->OnSuspending();
        s_in_suspend = true;
      }
    }
    else if (s_minimized)
    {
      s_minimized = false;
      if (s_in_suspend && game)
        game->OnResuming();
      s_in_suspend = false;
    }
    else if (!s_in_sizemove && game)
    {
      game->OnWindowSizeChanged(LOWORD(lParam), HIWORD(lParam));
    }
    break;

  case WM_ENTERSIZEMOVE:
	//サイズ変更が開始されたことを記録
    s_in_sizemove = true;
    break;

  case WM_EXITSIZEMOVE:
	//サイズ変更が終了したことを記録し,ゲームにウィンドウサイズの変更を通知
    s_in_sizemove = false;
    if (game)
    {
      RECT rc;
      GetClientRect(hWnd, &rc);

      game->OnWindowSizeChanged(static_cast<uint16_t>(rc.right - rc.left), static_cast<uint16_t>(rc.bottom - rc.top));
    }
    break;

  case WM_GETMINMAXINFO:
   //ウィンドウの最小トラックサイズを設定
  {
    auto info = reinterpret_cast<MINMAXINFO*>(lParam);
    info->ptMinTrackSize.x = 320;
    info->ptMinTrackSize.y = 200;
  }
  break;

  case WM_ACTIVATEAPP:
	//アプリケーションのアクティブ状態が変更されたときの処理
    if (game)
    {
      if (wParam)
      {
        game->OnActivated();
      }
      else
      {
        game->OnDeactivated();
      }
    }
    Keyboard::ProcessMessage(message, wParam, lParam);
    break;

  case WM_KEYDOWN:
  case WM_KEYUP:
  case WM_SYSKEYUP:
	//キーボード入力の処理
    Keyboard::ProcessMessage(message, wParam, lParam);
    break;

  case WM_POWERBROADCAST:
	//電源の状態変更に関する処理
    switch (wParam)
    {
    case PBT_APMQUERYSUSPEND:
	  //シスペンド状態への移行前に行う処理
      if (!s_in_suspend && game)
        game->OnSuspending();
      s_in_suspend = true;
      return TRUE;

    case PBT_APMRESUMESUSPEND:
      if (!s_minimized)
      {
        if (s_in_suspend && game)
          game->OnResuming();
        s_in_suspend = false;
      }
      return TRUE;
    }
    break;

  case WM_DESTROY:
	//ウィンドウが破棄されたときの処理
    PostQuitMessage(0);
    break;

  case WM_SYSKEYDOWN:
	//システムキーが押されたときの処理
    if (wParam == VK_RETURN && (lParam & 0x60000000) == 0x20000000)
    {
      //ALT+ENTERフルスクリーン切り替えの実装
      if (s_fullscreen)
      {
		//ウィンドウモードに切り替え
        SetWindowLongPtr(hWnd, GWL_STYLE, WS_OVERLAPPEDWINDOW);
        SetWindowLongPtr(hWnd, GWL_EXSTYLE, 0);

        uint16_t width = 800;
        uint16_t height = 600;

        if (game)
          game->GetDefaultSize(width, height);

        ShowWindow(hWnd, SW_SHOWNORMAL);

        SetWindowPos(hWnd, HWND_TOP, 0, 0, width, height, SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
      }
      else
      {
        SetWindowLongPtr(hWnd, GWL_STYLE, 0);
        SetWindowLongPtr(hWnd, GWL_EXSTYLE, WS_EX_TOPMOST);

        SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

        ShowWindow(hWnd, SW_SHOWMAXIMIZED);
      }

      s_fullscreen = !s_fullscreen;
    }
    Keyboard::ProcessMessage(message, wParam, lParam);
    break;

  case WM_MENUCHAR:
	  //メニューがアクティブで,ユーザーがモニックやアクセラレータキーに対応しないキーを押した場合に,
	  //エラービープを発生させないように無視する。
    return MAKELRESULT(0, MNC_CLOSE);
  }
  //デフォルトのウィンドウプロシージャにメッセージを渡す
  return DefWindowProc(hWnd, message, wParam, lParam);
}

//終了補助関数
void ExitGame()
{
  //メッセージキューに終了メッセージを送信
  PostQuitMessage(0);
}
